import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math

# TODO: someday I should replace this with a variant of my sparse-histogram
# code. It is easy to use and probably can be made faster than numpy for
# large datasets (by allowing the use of generators)

class Histogram(object):
    """Wrapper for numpy.histogram with additional conveniences.

    In addition to the behavior in numpy.histogram, this provides a few
    additional pathsimulators, as well as behavior that allows for better
    interactive use (tricks to assist caching by libraries using it, etc.)
    """
    def __init__(self, n_bins=None, bin_width=None, bin_range=None):
        """Creates the parameters for the histogram.

        Either `n_bins` or `bin_width` must be given. If `bin_width` is
        used, then `bin_range` is required. If `n_bins` is used, then
        `bin_range` is optional. `n_bins` overrides `bin_width`.

        If no options are given, the default is to use 40 bins and the
        range generated by np.histogram.
        """
        # this is to compare whether another histogram had the same setup,
        # and is useful for other programs that want to cache a histogram
        self._inputs = [n_bins, bin_width, bin_range]

        # regularize options
        self.bin_width = None # if not set elsewhere
        self.bin_range = None # if not set elsewhere
        if bin_range is not None:
            max_bin = max(bin_range)
            min_bin = min(bin_range)
            if bin_width is not None:
                self.bin_width = bin_width
                self.n_bins = int(math.ceil((max_bin-min_bin)/self.bin_width))
                # if this isn't actually divisible, you'll get one extra bin
            if n_bins is not None:
                self.n_bins = n_bins
                self.bin_width = (max_bin-min_bin)/(self.n_bins)
            self.bins = [min_bin + self.bin_width*i 
                         for i in range(self.n_bins+1)]
        else:
            if n_bins is not None:
                self.n_bins = n_bins
            else:
                self.n_bins = 20 # default
            self.bins = self.n_bins

        self.count = 0
        self.name = None
        self._histogram = None

    def add_data_to_histogram(self, data, weights=None):
        """Add `data` to an existing histogram; return resulting histogram"""
        if self._histogram is None:
            return self.histogram(data, weights)
        newhist = np.histogram(data, bins=self.bins, weights=weights)[0]
        newcount = len(data) if weights is None else sum(weights)
        for bin_i in range(len(newhist)):
            self._histogram[bin_i] += newhist[bin_i]
        self.count += newcount
        return self._histogram.copy()

    def histogram(self, data=None, weights=None):
        """Build the histogram based on `data`.

        Note
        ----
        Calling this with new data overwrites the previous histogram. This
        is the expected behavior; in using this, you should check if the
        histogram parameters have changed from a previous run (using
        `compare_parameters`) and you should be aware whether your data has
        changed. If you want to add data to the histogram, you should use
        `add_data_to_histogram`.
        """
        if data is not None:
            results = np.histogram(data, bins=self.bins, weights=weights)
            self._histogram = results[0]
            self.bins = results[1]
            # self.bins must be reset in case it was an integer (implicit
            # range) so we can have the correct bins if we use
            # `add_data_to_histogram` later
            self.count = len(data) if weights is None else sum(weights)
        elif self._histogram is None:
            raise RuntimeError("Histogram.histogram called without data!")
        return self._histogram.copy()

    def __call__(self):
        """Return copy of histogram if it has already been built"""
        return self.histogram()

    def compare_parameters(self, other):
        """Return true if `other` has the same bin parameters as `self`.

        Useful for checking whether a histogram needs to be rebuilt.
        """
        # None returns false: use that as a quick test
        if other == None:
            return False
        if type(other.bins) is not int:
            if type(self.bins) is int:
                return False
            for (t, b) in zip(self.bins, other.bins):
                if t != b:
                    return False
        else:
            return self._inputs == other._inputs
        return True

    def _normalization(self):
        """Return normalization constant (integral over this histogram)."""
        dx = [self.bins[i+1] - self.bins[i] for i in range(len(self.bins)-1)]
        norm = np.dot(self._histogram, dx)
        return norm

    # Yes, the following could be cached. No, I don't think it is worth it.
    # Keep in mind that we need a separate cache for each one that we build,
    # and that typically it will take almost no time to build one of these
    # (runtime in linear in number of histogram bins). Adding caching
    # complicates the code for no real benefit (you're more likely to suffer
    # from L2 cache misses than to get a speedup).

    def normalized(self, raw_probability=False):
        """Return normalized version of histogram.

        By default (`raw_probability` false), this returns the histogram
        normalized by its integral (according to rectangle-rule
        integration). If `raw_probability` is true, this returns the
        histogram normalized by the sum of the bin counts, with no
        consideration of the bin widths.
        """
        normed_hist = self.histogram() # returns a copy
        nnorm = self._normalization() if not raw_probability else self.count
        norm = 1.0/nnorm
        normed_hist = normed_hist * norm
        return normed_hist

    def cumulative(self, maximum=1.0):
        """Cumulative from the left: number of values less than bin value.

        Use `maximum=None` to get the raw counts.
        """
        cumul_hist = []
        total = 0.0
        for val in self._histogram:
            total += val
            cumul_hist.append(total)

        cumul_hist = np.array(cumul_hist)
        if maximum is not None:
            cumul_hist *= maximum / total
            
        return cumul_hist
    
    def reverse_cumulative(self, maximum=1.0):
        """Cumulative from the right: number of values greater than bin value.

        Use `maximum=None` to get the raw counts.
        """
        cumul_hist = []
        total = 0.0
        for val in reversed(self._histogram):
            total += val
            cumul_hist.insert(0, total)

        cumul_hist = np.array(cumul_hist)
        if maximum is not None:
            cumul_hist *= maximum / total
            
        return cumul_hist

    def rebinned(self, scaling):
        """Redistributes histogram bins of width binwidth*scaling

        Exact if scaling is an integer; otherwise uses the assumption that
        original bins were uniformly distributed. Note that the original
        data is not destroyed.
        """
        #TODO
        pass

    def plot_bins(self, scaling=1.0):
        """Bins used in plotting. Scaling useful when plotting `rebinned`"""
        # TODO: add scaling support
        return self.bins[1:]


def histograms_to_pandas_dataframe(hists, fcn="histogram", fcn_args={}):
    """Converts histograms in hists to a pandas data frame"""
    keys = None
    hist_dict = {}
    frames = []
    for hist in hists:
        # check that the keys match
        if keys is None:
            keys = hist.plot_bins(**fcn_args)
        for (t,b) in zip(keys, hist.plot_bins(**fcn_args)):
            if t != b:
                raise Warning("Bins don't match up")
        if hist.name is None:
            hist.name = str(hists.index(hist))

        hist_data = {
            "histogram" : hist.histogram,
            "normalized" : hist.normalized,
            "reverse_cumulative" : hist.reverse_cumulative,
            "cumulative" : hist.cumulative,
            "rebinned" : hist.rebinned
        }[fcn](**fcn_args)

        frames.append(pd.DataFrame({hist.name : hist_data}, index=keys))
    all_frames = pd.concat(frames, axis=1)
    return all_frames


def write_histograms(fname, hists):
    """Writes all histograms in list `hists` to file named `fname`
    
    If the filename is the empty string, then output is to stdout.
    Assumes that all files should have the same bins.
    """
    pass

# TODO: might as well add a main fucntion to this; read data / weight from
# stdin and output an appropriate histogram depending on some options. Then
# it is both a useful script and a library class!

